<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue CLI使用scss]]></title>
    <url>%2F2018%2F04%2F12%2Fvue%2F</url>
    <content type="text"><![CDATA[在Vue CLI脚手架中使用scss今天学习vue当中遇到了如何配置scss的问题经过查证，写出记录。 第一步: npm install sass-loader node-sass 或者 yarn add sass-loader node-sass 如果node-sass在Windows中安装失败(需要Python和C++构建工具），大家可以使用cnpm单独安装node-sass 第二步: 在vue文件中使用 12345678910111213141516171819&lt;style lang=&apos;scss&apos;&gt;#app &#123; @import url(&apos;./assets/aaa.scss&apos;); // 引入单独的scss文件 font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125; 这样就很愉快的完成了！使用Sass同理## Sass使用]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript递归函数]]></title>
    <url>%2F2018%2F03%2F27%2Fdigui%2F</url>
    <content type="text"><![CDATA[首先什么是递归 递归是一项非常重要的编程技巧，函数通过它调用其本身。 —msdn文档介绍 举个例子,常用的乘阶。 12345function factorial(i) &#123; if (i === 1) return i; return i* factorial(i - 1);&#125;console.log(factorial(5)); // 5*4*3*2*1 分几个步骤: 声明一个函数factorial，接受一个参数i。 判断i是否等于1，如果等于1则直接返回i。 如果i不等于1，则返回i * factorial(i - 1)，再次调用函数本身。(如此如果严格可以判断i是否大于等于0） 然后函数就会重复2 - 3两个步骤，直至i减到1为止。 JavaScript执行上下文栈 大家可以看看这个教程，我认为很不错！地址 JavaScript执行顺序。 123456789101112var foo = functiom () &#123; console.log(&apos;foo1&apos;)；&#125;foo();var foo = functiom () &#123; console.log(&apos;foo2&apos;)；&#125;foo();//最后会打印出//foo1//foo2 解释一下这个为什么不会被覆盖12345678910//上面的代码写成这样就比较好理解var foo;foo = function() &#123; console.log(&apos;foo1&apos;)&#125;foo()foo = function() &#123; console.log(&apos;foo2&apos;)&#125;foo() 123456789101112131415function foo() &#123; console.log(&apos;foo1&apos;);&#125;foo(); // foo2function foo() &#123; console.log(&apos;foo2&apos;);&#125;foo(); // foo2 再解释一下这个！123456789101112function foo() &#123; console.log(&apos;foo1&apos;);&#125;function foo() &#123; console.log(&apos;foo2&apos;);&#125;foo(); // foo2foo(); // foo2 函数被提升之后第二个覆盖了第一个，这是JavaScript作用域提升。 JavaScript的可执行代码有三种，全局代码，函数代码，eval代码 当执行到一个函数的时候就会进行准备工作，叫做执行上下文。 原博客把执行上下文说的很清楚了，我理解了一部分。有兴趣可以点击上面的连接继续了解，继续讲递归。 尾调用根据上面的知识，以及以前的知识，我们都知道递归会消耗大量内存，之执行一个函数就压入上下文栈，直至递归结束才会释放，造成递归占用大量内存。 尾调用，是指函数内部的最后一个动作是函数调用，改调用的返回值，直接返回给函数。 1234function f (x) &#123; return g(x)&#125;// 尾调用 12345function f(x) &#123; return g(x) - 1&#125;// 非尾调用 用上面的上下文栈，来看第二个函数，函数f执行指挥返回一个g函数而g函数的结果需要f函数作用域内 - 1才是结果，导致引用的时候g函数入栈的时候会持有f函数的作用域，f得不到释放，一直等g函数结束之后才会被释放。 现在优化一下上面的递归 12345function factorial(i, res) &#123; if(i === 1) return res; return factorial(i-1, i*res)&#125;console.log(factorial(4, 1)) 这样优化函数，保持返回的函数没有上个函数的引用，这样上个函数在入栈之后执行到return之后就会被释放，而不会和上面的递归一样等到最终结果才会被释放。（ps。JavaScript上下文栈，需要好好看看比较重要） ## javaScript]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[占领未来的打包工具---Parcel（介绍）]]></title>
    <url>%2F2018%2F03%2F19%2FpackParcelOne%2F</url>
    <content type="text"><![CDATA[基本概况最近大家都在关注一个很流行的类似 webpack 的前端构建工具 Parcel。这个库刚出来没多久(截至目前发布几十天)，但是很受欢迎，看下图就知道它到底有多火了。 这么火的东西我们怎么能不学呢？那么它到底火在哪儿？来看看我的示例分析(教程)吧！！！ 官方介绍地址官方地址：https://parceljs.org/ GitHub地址：https://github.com/parcel-bundler/parcel Parcel VS Webpack听我扯一扯介绍这个库之前，我来说一下我个人觉得 webpack 的一些不好的地方（相对于 Parcel）。 1、需要写配置文件（webpack.config.js），可能每使用一个功能，比如加载图片或 css，都要添加配置，要维护配置文件，而 Parcel 不需要。 2、感觉编译或加载速度有些慢，特别是库多或项目复杂的时候，虽然有一些办法代码拆分的方法可以解决，比如 CommonsChunkPlugin 或 DLLPlugin 之类的，但这些方法有些复杂。 官方数据 打包速度 真的飞一般的感觉吧！！！ 学习成本 webpack需要一定的时间去学习如何使用而 Parcel 有很多优点，可以不使用配置文件，也就是说你只管写代码，它会自动运行，很智能化，打个比方吧，比如在 webpack 中如果要处理 css，那得要安装和加载一个 css 的 loader，然后配置文件写上几行，可是 Parcel 不需要，直接用就行。Parcel 学习起来比较简单，基本上可以说 “不用学习”，只是使用就可以了。除此之外 模块热替换和代码拆分的功能，Parcel 也有，还有，如果要你用 Parcel 写一个 react 的运行环境，可能不需要配置任何内容，只要安装几个 react 的包就可以用起来了。 说了这么多，我还是要把官方对它的特性进行概括的图片放出来： 说到这里小伙伴们是不是和我当初一样心动了呢？ 下一篇博客我们一起上手玩起来吧！！！]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基础范例]]></title>
    <url>%2F2018%2F03%2F13%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[你好，前端第一篇文章哦三级标题123# 你好，前端## 第一篇文章哦### 三级标题 列表1 列表2 a 次列表 b 此列表 列表三 12345- 列表1- 列表2 a 次列表 b 此列表- 列表三 博客导航 1[博客导航](http://www.aemple.top) 字体斜体字体加粗 1234![图片](/images/avatar.jpg)*字体斜体***字体加粗** &lt;html&gt;&lt;/html&gt; 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;我是标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;啦啦啦啦&lt;h1&gt; &lt;/body&gt;&lt;/html&gt; 我是应用块哦 1&gt;我是应用块哦 这些都经常用到希望小伙伴们加深记忆]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello-Hexo]]></title>
    <url>%2F2018%2F03%2F13%2FhelloHexo%2F</url>
    <content type="text"><![CDATA[第一次当然要hello啦，我是邓波，是你小粉丝。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
