<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈Http1.0/Http1.1/Http2.0/Https]]></title>
    <url>%2F2018%2F06%2F08%2Fhttp%2F</url>
    <content type="text"><![CDATA[首先来看看Http的发展（此图来自 code小生）HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议，最后一个就是2015年发布的http2.0。 HTTP 1.0 → HTTP 1.1长连接HTTP 1.1默认支持长连接，减少了TCP连接次数，节约开销。 HTTP 1.0所保持的TCP每次只能处理一个请求，最典型的就是pipline管线化模型，虽然能一次性接收多个请求，但是还是得按顺序一次处理一个请求，这样很容易造成后续请求等待前序请求完成，造成阻塞，也就是我们常说的”线头阻塞”。 总结：HTTP 1.0需要使用keep-alive参数来告知服务器建立长连接，而HTTP 1.1默认支持长连接，减少了TCP连接次数，减少了开销和延迟！！！ 缓存HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准。 HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略 新增状态码：HTTP1.1 中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删！ http1.1带宽优化HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。HTTP1.1在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 HOST域HTTP 1.1支持host域，服务端可以通过host域设置多个虚拟站点来共享一个ip和端口。因为随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname） HTTP 1.1 → HTTP 2.0多路复用HTTP 2.0使用多路复用技术，使用一个TCP连接_并发_处理多个请求，不但节约了开销而且可处理请求的数量也比HTTP 1.1大了很多。 当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。 头部压缩HTTP 1.1不支持header数据压缩，HTTP 2.0使用HPACK算法对header的数据进行压缩，使得数据传输更快。 服务器推送当我们对支持HTTP 2.0的服务器请求数据额时候，服务器会顺便把一些客户端需要的资源一起推送到服务器，这种方式适用于加载静态资源，节约带宽。服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。 注意 HTTP → HTTPS HTTPS = HTTP + TLS/SSL加密 + 认证 + 完整性保护 （80 443）在讲 HTTPS 之前，我们先来看看 HTTP 有哪些不足： 使用明文通信，内容可能会被窃听 不验证通信双方身份，有可能遭遇伪装 无法证明报文的完整性，内容可能遭到篡改 为了解决这些不足，所以HTTPS 应运而生，先看看https的特性： TLS/SSL内容加密 数字证书(CA)验明身份: 防范中间人攻击 MD5、SHA-1等散列值方法防止信息篡改（中间人攻击：运营商等） 先来谈谈“对称加密”和“非对称加密”的概念对称加密 所谓的“对称加密技术”，意思就是说：“加密”和“解密”使用相同的密钥。这个比较好理解，就好比你用 7zip 或 WinRAR 创建一个带密码（口令）的加密压缩包，当你下次要把这个压缩文件解开的时候，你需要输入同样的密码，在这个例子中，密码/口令就如同刚才说的“密钥”。 对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key），这种方法在密码学中叫做对称加密算法，对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。 非对称加密 所谓的“非对称加密技术”，意思就是说：“加密”和“解密”使用不同的密钥，这玩意儿比较难理解，也比较难想到，当年“非对称加密”的发明，还被誉为“密码学”历史上的一次革命。非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key），私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人，非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。 总结：非对称相对更安全，但是性能要求更高！https加密方式虽然TLS/SSL采用公开密钥这种非对称加密方式，但是HTTPS并不是全部使用非对称加密，而是使用混合加密方式，即：公开密钥(非对称加密)+共享密钥(对称加密) 因为公开密钥与共享密钥加密相比，其处理速度要慢很多。所以HTTPS冲锋利用了两者各自的优势，将多种方法组合起来用于通信。https在交换密钥环节使用公开密钥加密方式，之后建立的通信交换报文阶段则使用共享密钥加密方式 证明公开密钥的正确性的证书遗憾的是, 公开密钥加密方式还是存在一些问题的, 那就是无法证明公开密钥本身就是货真价实的公开密钥. 比如, 正准备和某台服务器建立公开密钥加密方式下的通信时, 如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥. 或许在公开密钥传输途中, 真正的公开密钥已经被攻击者替换了. 为了解决上述问题, 可以使用有数字证书认证机构（CA）和其他相关机关颁发的公开密钥证书 基本流程为: 1.服务器把自己的公开密钥登录至数字证书认证机构 2.数字证书认证机构用自己的私有密钥向服务器的公开密钥署数字签名并颁发公钥证书 3.客户端拿到服务器的公钥证书后, 使用数字证书认证机构的公开密钥, 向数字证书认证机构验证公钥证书上的数字签名, 以确认服务器的公开密钥的真实性 4.使用服务器的公开密钥对报文加密后发送 5.服务器用私有密钥对报文解密 性能问题通常我们会认为，使用HTTPS会导致网站加载速度变慢。实际上，只要我们合理优化使用HTTPS过程，使用HTTPS可能会比使用HTTP还快！使用HTTPS相比于HTTP所增加的延迟点： HTTP 302 跳转到 HTTPS 的耗时 CPU 进行 RSA 加解密运算的耗时 请求和验证 CA 所花的时间 优化方式： 使用 HSTS 技术，去掉从80跳转到443的跳转(HSTS使用的是内部307跳转技术，不会产生多余的网络请求) PS：302 和 307 效果相同，只是307强制使用post 使用专门的加解密硬件处理加解密，减轻CPU负担。这样不仅减少了处理时间，所能承受的qps也会增加。 减少证书链，减少 CA 请求时间 session复用，减少建立连接的次数 为什么不都使用https 性能问题 金钱问题 参考HTTP1.0、HTTP1.1 和 HTTP2.0 的区别HTTP、SSL/TLS和HTTPS协议的区别与联系]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue CLI使用scss]]></title>
    <url>%2F2018%2F04%2F12%2Fvue%2F</url>
    <content type="text"><![CDATA[在Vue CLI脚手架中使用scss今天学习vue当中遇到了如何配置scss的问题经过查证，写出记录。 第一步: npm install sass-loader node-sass 或者 yarn add sass-loader node-sass 如果node-sass在Windows中安装失败(需要Python和C++构建工具），大家可以使用cnpm单独安装node-sass 第二步: 在vue文件中使用 12345678910111213141516171819&lt;style lang=&apos;scss&apos;&gt;![scss](https://tse4-mm.cn.bing.net/th?id=OIP.HuHbi6D0rpzsTenMxWgfXgHaFj&amp;w=253&amp;h=184&amp;c=7&amp;o=5&amp;pid=1.7)#app &#123; @import url(&apos;./assets/aaa.scss&apos;); // 引入单独的scss文件 font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125; 这样就很愉快的完成了！使用Sass同理## Sass使用]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天上便落下一粒沙，从此便有了撒哈拉--初入大学]]></title>
    <url>%2F2018%2F04%2F09%2FSH-1%2F</url>
    <content type="text"><![CDATA[我的大学生活 “准”大学生活: 高考后感觉身上的担子轻了，是到放松任性玩儿的时候了，于是高考后的六月七月都被我放肆的挥霍了。就在七月末的时候，突然冒出了一个奇怪的想法。 我想去找一份工作尝试着靠自己的能力来拿到一笔完完全全属于自己的money，但当时因为暑假已经不多了，所以在寻找了大概一个星期后也没有找到合适的。最后这个挺不错的想法，也被我否定了。剩下的时间，就回到了自己的家乡，开始着手准备迎接我的大学生活。 但回家后的生活过的也分的颓废，每天大概一两点睡差不多11点起床然后吃了饭之后可能又是躺尸啊，因为天气比较热。离去大学报到的时间越来越近了，我开始去网上寻找大学需要准备一些什么东西，然后心满意足的买了各种各样自己认为可能会需要的东西，在2016年9月2号的时候，我拖着它们来到了属于我的大学，开始了我的大学生活。 大学生活的开始（大一上学期）:军训 进入大学最开始的一件事可能就是军训了。我对军训的记忆就是累和放松，感到累，是因为每天要在特别热的环境下训练，不经意间，可能你还会收到教官的体罚。感到放松是因为每次休息或者教官带我们拉军歌大家一起玩，一起小游戏都会让你感觉特别的放松。 社团、学生会 军训后差不多就是学生会的招募了，当时面对各种各样的学生会自己感到很迷茫，对他们都没有太多的了解。他后来抱着自己想当一名志愿者，去帮助一下别人想法。经过了一轮面试，二轮面试，试用期这几个步骤终于成为了一名青协小干事。学生会给我留下的记忆就是温暖禾迷茫。会感到温暖欣慰，学生会是一个特别大的大家庭，每个人都是互相帮助来完成这个大家庭应该去完成的事情，而且在如果说某个人过生日，大家都会一起帮你过，常一起出去玩，一起做一些小活动，所以会感觉到温暖。感动迷茫，是因为很多事情自己之前都没有接触过功能无论是在对人或者对物都遇到了很多之前没遇到过的情景。刚加入学生会去死，学到了挺多认识到了许多许多新的朋友，知道了许多做事儿做人的方法。 专业方向加入学生会后不久学校或者学院特色的学长课堂开课了，当时我对学长课堂的各个方向基本都不太了解，在询问的几个学长之后。他们给出了我一些建议，最后选择了前端这个方向，能够选择到这个方向感觉也是人生对一种幸运，学长课堂在大二或者说大一下期仍然保留着的并不多，而就是其中一个，当时代前段的学长也不止一个到现‘在保留的却只有教我的学长还在带我们。在学长课堂的学习过程中学会的也不仅仅是一些专业知识。觉得自己更加去学会了去运用一些东西些论坛一些搜索引擎来解决问题的思想和方法。 大学课堂“自觉”是我对大学课堂的认识，在大学的课堂老司机的人不会在意你听课了，或者没有听课，老师也不会特别严苛的去检查你的任何关于学习的方面。 时间很快，差不多就到一个学期就这么过去了，一直踩着好运的我也以班级第二的成绩，哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈。 持续更新中···········]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css之正方体]]></title>
    <url>%2F2018%2F04%2F02%2Fcss-zft%2F</url>
    <content type="text"><![CDATA[最近给大一的上课，想找一篇通俗点css制作立方体的文章给他们看，实在没找到最后索性就自己写一篇吧！！！第一步：大家需要有css3的基础,没有css3基础的可以先移步这里 css3第二步：先把下图牢牢地记住 第三步：搭建页面主体结构12345678910&lt;div class=&quot;stage&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;face top&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;face back&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;face bottom&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;face front&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;face left&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;face right&quot;&gt;6&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 第四步 ：编写基础css12345678910111213141516171819202122232425262728293031323334* &#123; margin: 0; padding: 0; //清除默认样式 &#125; .stage &#123; position: relative; //让子元素相对父元素定位 margin: 300px 0 0 300px; perspective: 800px;//css3动画属性 width: 200px; height: 200px; &#125; .container &#123; width: 200px; height: 200px; position: absolute;//让自己可以相对父元素定位 transform-style: preserve-3d;//css3动画属性 &#125; .face &#123; width: 100%; height: 100%; position: absolute;//让自己可以相对父元素定位，并达到六个div重合效果 left: 0; top: 0; text-align: center;//字水平居中 line-height: 200px;//字垂直居中 font-size: 50px; color: #fff; border: 1px solid #ccc; opacity: 0.6;//设置透明度方便观察效果 background: #999; &#125; 下面看看现在的效果 六个div重合在一起了 第五步：把每个div盒子定位到它应该在的地方1234567891011121314151617181920212223242526272829303132.top &#123; color: aqua;//设置字体颜色方便观察 transform: rotateX(90deg) translateZ(100px); //这里就是重点了 现在回想刚才记住的坐标图 我们先绕X旋转90度 //这时候不仅div盒子变化了位置并且现在x y z三轴的方向也会随之改变！！！！ //z变成了原来的y方向 y又变成原来的z方向 所以此时我们再向z移动100px就到了顶部 &#125; .back &#123; color: red; transform: translateZ(-100px); &#125; .bottom &#123; color: bisque; transform: rotateX(90deg) translateZ(-100px); &#125; .front &#123; color: palegreen; transform: translateZ(100px); &#125; .left &#123; color: rebeccapurple; transform: rotateY(90deg) translateZ(100px); &#125; .right &#123; color: darkorange; transform: rotateY(90deg) translateZ(-100px); &#125; 看看现在的效果 如下图现在已经是一个正方体了但是却还不明显 我们让它总体沿着y轴旋转30° 在.container下加 transform:rotateY(35deg); 得到下图 最后我们加一个动画123456789@keyframes zhuan &#123; from &#123; transform: rotateX(0deg) rotateY(0deg); &#125; to &#123; transform: rotateX(360deg) rotateY(360deg); &#125;&#125; 就达到了如图结果：]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈--forEach、for in、for of、for]]></title>
    <url>%2F2018%2F03%2F29%2Fjs-%E5%BE%AA%E7%8E%AF%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[forEach从ES5开始 Javascript内置了forEach方法 用来遍历数组 对只能是数组！！！ 12345 let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]arr.forEach(function (val, index, arr) &#123; // val是当前元素，index当前元素索引，arr当前数组 //this：window&#125;) 划重点上面的forEach里的this =&gt; window 怎么改呢？ 就是利用forEach的第二个参数了！！！ 12345 let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]arr.forEach(function (val, index, arr) &#123; // val是当前元素，index当前元素索引，arr当前数组 //this =&gt;obj&#125;,obj) 总结：写法简单了很多，但是也存在一个局限 就是你不能中断循环(使用break语句或使用return语句），而且只支持数组 for…infor-in循环实际是为循环”enumerable“对象而设计的,当然也可以用于数组，但是不推荐 12345let obj = &#123;a: &apos;1&apos;, b: &apos;2&apos;, c: &apos;3&apos;, d: &apos;4&apos;&#125;for (let index in obj) &#123; console.log(index) //遍历的实际上是对象的属性名称 a,b,c,d console.log(obj[index]) //这个才是属性对应的值1，2，3，4&#125; 以上代码会出现的问题：1.index 值 会是字符串（String）类型2.循环不仅会遍历数组元素，还会遍历任意其他自定义添加的属性。 for-of 首先它是ES6中新增加的语法 遍历数组 1234 let arr = [&apos;China&apos;, &apos;America&apos;, &apos;Korea&apos;]for (let o of arr) &#123; console.log(o) //China, America, Korea&#125; 它并不能循环一个普通对象1234let obj = &#123;a: &apos;1&apos;, b: &apos;2&apos;, c: &apos;3&apos;, d: &apos;4&apos;&#125;for (let o of obj) &#123; console.log(o) //Uncaught TypeError: obj[Symbol.iterator] is not a function&#125; 但是可以循环一个拥有enumerable属性的对象。如果我们按对象所拥有的属性进行循环，可使用内置的Object.keys()方法1234let obj = &#123;a: &apos;1&apos;, b: &apos;2&apos;, c: &apos;3&apos;, d: &apos;4&apos;&#125;for (let o of Object.keys(obj)) &#123; console.log(o) // a,b,c,d&#125; 如果我们按对象所拥有的属性值进行循环，可使用内置的Object.values()方法1234let obj = &#123;a: &apos;1&apos;, b: &apos;2&apos;, c: &apos;3&apos;, d: &apos;4&apos;&#125;for (let o of Object.values(obj)) &#123; console.log(o) // 1,2,3,4&#125; 循环一个字符串1234let str = &apos;love&apos;for (let o of str) &#123; console.log(o) // l,o,v,e&#125; 循环一个Map12345678910111213for (let [key, value] of iterable) &#123; console.log(value);&#125;// 1// 2// 3for (let entry of iterable) &#123; console.log(entry);&#125;// [a, 1]// [b, 2]// [c, 3] 循环一个Set12345678let iterable = new Set([1, 1, 2, 2, 3, 3]);for (let value of iterable) &#123; console.log(value);&#125;// 1// 2// 3 循环一个类型化数组1234567let iterable = new Uint8Array([0x00, 0xff]);for (let value of iterable) &#123; console.log(value);&#125;// 0// 255 总结：1.可以避免所有 for-in 循环的陷阱 2.不同于 forEach()，他可以使用 break, continue 和 return 3.for-of 循环不仅仅支持数组的遍历。同样适用于很多类似数组的对象 4.它也支持字符串的遍历 5.for-of 并不适用于处理原有的原生对象]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript递归函数]]></title>
    <url>%2F2018%2F03%2F27%2Fdigui%2F</url>
    <content type="text"><![CDATA[首先什么是递归 递归是一项非常重要的编程技巧，函数通过它调用其本身。 —msdn文档介绍 举个例子,常用的乘阶。 12345function factorial(i) &#123; if (i === 1) return i; return i* factorial(i - 1);&#125;console.log(factorial(5)); // 5*4*3*2*1 分几个步骤: 声明一个函数factorial，接受一个参数i。 判断i是否等于1，如果等于1则直接返回i。 如果i不等于1，则返回i * factorial(i - 1)，再次调用函数本身。(如此如果严格可以判断i是否大于等于0） 然后函数就会重复2 - 3两个步骤，直至i减到1为止。 JavaScript执行上下文栈 大家可以看看这个教程，我认为很不错！地址 JavaScript执行顺序。 123456789101112var foo = functiom () &#123; console.log(&apos;foo1&apos;)；&#125;foo();var foo = functiom () &#123; console.log(&apos;foo2&apos;)；&#125;foo();//最后会打印出//foo1//foo2 解释一下这个为什么不会被覆盖12345678910//上面的代码写成这样就比较好理解var foo;foo = function() &#123; console.log(&apos;foo1&apos;)&#125;foo()foo = function() &#123; console.log(&apos;foo2&apos;)&#125;foo() 123456789101112131415function foo() &#123; console.log(&apos;foo1&apos;);&#125;foo(); // foo2function foo() &#123; console.log(&apos;foo2&apos;);&#125;foo(); // foo2 再解释一下这个！123456789101112function foo() &#123; console.log(&apos;foo1&apos;);&#125;function foo() &#123; console.log(&apos;foo2&apos;);&#125;foo(); // foo2foo(); // foo2 函数被提升之后第二个覆盖了第一个，这是JavaScript作用域提升。 JavaScript的可执行代码有三种，全局代码，函数代码，eval代码 当执行到一个函数的时候就会进行准备工作，叫做执行上下文。 原博客把执行上下文说的很清楚了，我理解了一部分。有兴趣可以点击上面的连接继续了解，继续讲递归。 尾调用根据上面的知识，以及以前的知识，我们都知道递归会消耗大量内存，之执行一个函数就压入上下文栈，直至递归结束才会释放，造成递归占用大量内存。 尾调用，是指函数内部的最后一个动作是函数调用，改调用的返回值，直接返回给函数。 1234function f (x) &#123; return g(x)&#125;// 尾调用 12345function f(x) &#123; return g(x) - 1&#125;// 非尾调用 用上面的上下文栈，来看第二个函数，函数f执行指挥返回一个g函数而g函数的结果需要f函数作用域内 - 1才是结果，导致引用的时候g函数入栈的时候会持有f函数的作用域，f得不到释放，一直等g函数结束之后才会被释放。 现在优化一下上面的递归 12345function factorial(i, res) &#123; if(i === 1) return res; return factorial(i-1, i*res)&#125;console.log(factorial(4, 1)) 这样优化函数，保持返回的函数没有上个函数的引用，这样上个函数在入栈之后执行到return之后就会被释放，而不会和上面的递归一样等到最终结果才会被释放。（ps。JavaScript上下文栈，需要好好看看比较重要） ## javaScript]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[占领未来的打包工具---Parcel（介绍）]]></title>
    <url>%2F2018%2F03%2F19%2FpackParcelOne%2F</url>
    <content type="text"><![CDATA[基本概况最近大家都在关注一个很流行的类似 webpack 的前端构建工具 Parcel。这个库刚出来没多久(截至目前发布几十天)，但是很受欢迎，看下图就知道它到底有多火了。 这么火的东西我们怎么能不学呢？那么它到底火在哪儿？来看看我的示例分析(教程)吧！！！ 官方介绍地址官方地址：https://parceljs.org/ GitHub地址：https://github.com/parcel-bundler/parcel Parcel VS Webpack听我扯一扯介绍这个库之前，我来说一下我个人觉得 webpack 的一些不好的地方（相对于 Parcel）。 1、需要写配置文件（webpack.config.js），可能每使用一个功能，比如加载图片或 css，都要添加配置，要维护配置文件，而 Parcel 不需要。 2、感觉编译或加载速度有些慢，特别是库多或项目复杂的时候，虽然有一些办法代码拆分的方法可以解决，比如 CommonsChunkPlugin 或 DLLPlugin 之类的，但这些方法有些复杂。 官方数据 打包速度 真的飞一般的感觉吧！！！ 学习成本 webpack需要一定的时间去学习如何使用而 Parcel 有很多优点，可以不使用配置文件，也就是说你只管写代码，它会自动运行，很智能化，打个比方吧，比如在 webpack 中如果要处理 css，那得要安装和加载一个 css 的 loader，然后配置文件写上几行，可是 Parcel 不需要，直接用就行。Parcel 学习起来比较简单，基本上可以说 “不用学习”，只是使用就可以了。除此之外 模块热替换和代码拆分的功能，Parcel 也有，还有，如果要你用 Parcel 写一个 react 的运行环境，可能不需要配置任何内容，只要安装几个 react 的包就可以用起来了。 说了这么多，我还是要把官方对它的特性进行概括的图片放出来： 说到这里小伙伴们是不是和我当初一样心动了呢？ 下一篇博客我们一起上手玩起来吧！！！]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基础范例]]></title>
    <url>%2F2018%2F03%2F13%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[你好，前端第一篇文章哦三级标题123# 你好，前端## 第一篇文章哦### 三级标题 列表1 列表2 a 次列表 b 此列表 列表三 12345- 列表1- 列表2 a 次列表 b 此列表- 列表三 博客导航 1[博客导航](http://www.aemple.top) 字体斜体字体加粗 1234![图片](/images/avatar.jpg)*字体斜体***字体加粗** &lt;html&gt;&lt;/html&gt; 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;我是标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;啦啦啦啦&lt;h1&gt; &lt;/body&gt;&lt;/html&gt; 我是应用块哦 1&gt;我是应用块哦 这些都经常用到希望小伙伴们加深记忆]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello-Blog]]></title>
    <url>%2F2018%2F03%2F13%2FhelloHexo%2F</url>
    <content type="text"><![CDATA[第一次当然要hello啦，我是邓波，是你小粉丝。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
